#Крипто

[Криптография. Конспект номер два]
## Симметричные шифры
   Блочные шифры
		1.1 Шифры замены
			1.1 Моноалфавитные
				Шифр Цезаря 
				  Шифровка - c=(a+x)modN, x-сдвиг
				  Дешифровка - a=(c-x)modN
				Афинный шифр
				  Шифровка - c=(ax+b)modN, где a и b взаимнопростые.
				  Дешифровка - c=a^(-1)(x-b)modN
			
			1.2 Полиалфавитные
				Шифр Виженера - c=(a+b)modN, b-соответсв.символу ключа
				Шифр Тритемиуса
				Гронсвельда
				Диск Альберти
			
			1.4 Омофонические (по факту он моноалфавитный, тк.к. алфавит не меняется)
				Книжный шифр - указание на позиицию буквы в книге
				Криптограммы Бейла
				Шифр Зодиака
			
			1.5 Полиграммные
				Шифр Плейфера
				Шифр Хилла
				Шифр Порты	
			
			1.6 Коды
				Китайский телеграфный код
				Азбука Морзе
				Двоичный код
				Троичный код
				Код Грея
				Код Бодо
				ASCII, utf-8
				Код Шеннона-Фано
			    Код Хаффмана
				
		1.2 Шифры перестановки
			2.1 Простая перестановка[
				Решетка Кардано (Трафарет)
				Анаграммы (Детская перестановка)	
			
			2.2 Маршрутная перестановка
				Двойная перестановка (https://ru.wikipedia.org/wiki/Перестановочный_шифр)
				Квадрат Полибия https://ru.wikipedia.org/wiki/Квадрат_Полибия
				Бустрофедон https://ru.wikipedia.org/wiki/Бустрофедон
				Скитала
				
		1.3 Композиционные шифры
			Advanced Encryption Standart???????????????????????????????

			Data Encryption Standart
			  [Начальная перестановка IP]
				По таблице первие 3 бита результирующего блока IP(T) после начальной перестановки IP  являются битами 58, 50, 42 входного блока T, а 3 последних - 23, 15, 7
			  [Циклы Шифрования]
				1) IP(T) делится на два блока L0, R0 по 32бит
				2) L(i) = R(i-1); R(i) = L(i-1) XOR F(R(i-1), K(i))
			  [Основная функция шифрования (Функция Фейстеля)]
				1) Функция расширения Е
				2) Сложение по модулю 2 с ключом k(i)
				3) Преобразование S, состоящее из восьми преобразований S-блоков
				4) Перестановка Р
				(Функция Е преобразует 32-битовый вектор R(i-1) до 48-битового вектора E(R(i-1)))

			Сеть Файстеля(1971г.) https://ru.wikipedia.org/wiki/Сеть_Фейстеля#Шифрование
			  [Шифрование]
				1) Выбранный блок информации делится на два подблока L0, R0
				2) Правый подблок R0 изменяется функцией F и использованем раунд.ключа K - x=F(R0, K0)
				3) Результат x = x XOR L0
				4) R1 = x; L1 = R0
				5) Вычисляется новый раундовый ключ.
				L(i-1) = R(i) xor F(L(i), K(i-1)); R(i-1) = L(i)
			  [Расшифрока] - подача данных в обратном порядке
			ГОСТ 28147-89
			
	1.2 Поточные шифры
			?Шифр Вернама - a xor b, b-соответсв.символу ключа
			SEAL
			WAKE
			RC4
			
	
2. Ассиметричные шифры
	Алгоритм Диффи-Хеллмана(1976г), https://ru.wikipedia.org/wiki/Протокол_Диффи_—_Хеллмана#Описание_алгоритма
	    1) Генерация натуральных чисел a и b - закрытых ключей
		2) Генерация случайного простого числа p,  g - первообразный корень по модулю p; (с каждой стороны)
		3) Вычисление открытого ключа A = (g**a)mod(p),  B = (g**b)mod(p)
		4) Обмен открытыми ключами с удаленной стороной
		5) Вычисление Общего секретного ключа K = (B**a)mod(p), где B -  открытый ключ удаленной стороны
		6) общий ключ K = (g**ab)mod(p) = (A**b)mod(p) = (B**a)mod(p)
	
	RSA(1977г.) - Rivest Shamir Adleman https://ru.wikipedia.org/wiki/RSA#Описание_алгоритма
	  [Алгоритм создания ключей]
		1) выбор двух различных случайных числа P и Q заданного размера
		2) Вычисляется число N = P * Q, называющееся Модулем
		3) Вычисляется значение функции Эйлера от числа N - phi = (p-1)(q-1)
		4) Выбор целого числа "е" (открытой экспоненты) взаимно простое со значением функции Эйлера и меньшее чем оно.
		5) Вычисление числа "d" (закрытой экспоненты), мультипликативноо обратного числу "e" по модулю функции Эйлера. (d*e)mod(phi)=1 либо через расширенный алгоритм Евклида
		6) Пара (е, n) - public key;  пара (d, n) - private key
	  [Алгоритм шифровки и дешифровки]
		7) c = (m**e)modN; m = (c**d)modN
	
	Схема Эль-Гамаля(1985г.) https://ru.wikipedia.org/wiki/Схема_Эль-Гамаля#Генерация_ключей
	  [Генерация ключей]
		1) Генерируется случайное простое число p
		2) Выбирается целое число g -- первообразный корень p
		3) Выбирается случайное целое число x(1 < x < p-1)
		4) Вычисляется y = (g**x)mod(p)
		5) открытым ключом является (y, g, p), закрытым - число x
	  [Шифрование]
		Условие - Сообщение M должно быть меньше числа p
		1) Выбирается сессионный ключ k(1 < k < p-1)
		2) Вычисляются числа a = (g**k)mod(p) и b = ((y**k)*M)mod(p)
		3) Пара чисел (a, b) - шифротекст.
		Nota Bena - длина шифротекта вдвое больше исходного сообщения M
	  [Расшифрование]
		M = b(a**x)**(-1) = (b*(a**(p-1-x)))mod(p)
	  [Режим подписи сообщений]
		1) Вычисляется хэш-сумма сообщения M=H(M), хэш-функция -- любая.
		2) Выбирается случайное число k(1 < k < p-1) взаимно простое с p-1 и вычисляется r = (g**k)mod(p)
		3) Вычисляется число s = ((m - x*r)*(k**(-1)))mod(p-1). Это мультипликативное обратное k  по модулю p-1,
		   которое можно найти с помощью расширенного алгоритма Евклида
		4) Подписью сообщения M  является пара (r, s)
	  [Проверка подписи]
		Требуется открытый ключ (p, g, y), подпись (r, s)
		1) Проверяется выполнимость условий 0<r<p ; 0<s<p-1
		2) Если хоть одно условие не выполняется, подпись считается неверной
		3) Вычисляется хэш-сумма m = H(M)
		4) Подпись считается верной если выполняется: (y**r)*(r**s) == (g**rn)mod(p)
		
	DSA(1991г.) - Digital Signature Algorithm -- Алгоритм Цифровой Подписи, https://ru.wikipedia.org/wiki/DSA#Открытый_и_секретный_ключи
	  [Алгоритм построения системы подписи сообщения]
		1) Выбор криптографической хэш-функции H(x)
		2) Выбор простого числа q размерность N  которого в битах совпадает с размерностью в битах значений хэш-функции
		3) Выбор простого числа p, что  (p-1) делится на q. Битовая длина p = L
		4) Выбор такого числа g(g!=1), что его мультипликативный порядок по модулю p равен q. g=h**((p-1)\q), h - число (1; p-1)
	  [Открытый и секретный ключи]
		1) Открытый ключ x(0, q)
		2) Закрытый ключ y=(g**x)mod(p)
	  [Подпись сообщения]
		1) Выбор случайного числа k(0, q)
		2) Вычисление r=((g**k)mod(p))mod(q)
		3) Если r==0, выбрать другое число k
		4) Перечисление s=(k**(-1))*(H(m)+x*r)mod(q)
		5) Если s==0, выбрать другое число k
		6) Подписью является пара (r, s) общей длины 2N
	  [Проверка подписи]
		1) Вычисление w=(s**(-1))mod(q)
		2) Вычисление u1 = (H(m)*w)mod(q)
		3) Вычисление u2 = (r*w)mod(q)
		3) Вычисление v = ((g**u1)*(y**u2)mod(p))mod(q)
		5) Подпись верна при условии v = r 

Нота Бена
Принцип Кирхгоффа
Расширенный алгоритм Евклида
Малая теорема Ферма